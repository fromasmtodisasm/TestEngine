////////////////////////////////////////////////////////////////////////////////////////////////////
//  Description: Common include file for ALL shaders 
//	 - only add when really necessary, this will propagate to ALL shaders
////////////////////////////////////////////////////////////////////////////////////////////////////

#define PI 3.1415
#define PI_X2 6.2831
#define PI_X4 12.5663

#define PERFRAME_SLOT b0
#define LIGHTS_SLOT   b1
#define PERVIEW_SLOT  b2
#define PERDRAW_SLOT  b3
#define MATERIAL_SLOT  b4

//=== Common definitions =========================================================

#include "FXStreamDefs.cfi"
#include "FXConstantDefs.cfi"
#include "FXSamplerDefs.cfi"

//#include "AuxGeom.cfx"
//#include "NoDraw.cfx"
//#include "Common.cfx"


float global_float <string desc="Test global variable";> = 0.5;

float global_float2 <string desc="Test global variable";> = float(0);
float2 global_float3 <string desc="Test global variable";> = float2(0, 0);

//struct struct_definition
//{
//    float4x4 Projection;
//    float data[3];
//    float data2[3][4];
//};
//
//ConstantBuffer<struct_definition> cbTest;

struct Light
{
    float3 Pos;
    float3 Color;
};


cbuffer PerFrameCB : register(PERFRAME_SLOT)
{
    float4 SunDirection;
    float4 SunColor;
    float4 AmbientStrength;
    float4 LightIntensity;
    float fogStart;
    float fogEnd;
    float3 fogColor;
    int NumLights;
};

#define NUM_LIGHTS 4
cbuffer LightsCB : register(LIGHTS_SLOT)
{
    Light g_Lights[NUM_LIGHTS];
};

cbuffer PerViewCB : register(PERVIEW_SLOT)
{
    struct PERVIEWCB
    {
        float4x4 Projection;
        float4x4 OrthoProjection;
        float4x4 View;
        float4x4 ViewProjection;
        float3 Eye;
    } perViewCB;
}

cbuffer PerDrawCB : register(PERDRAW_SLOT)
{
    float4x4 Model;
    float4x4 World;
    float4x4 MVP;
    float4x4 MV;
    bool ApplyGrayScale;
};

cbuffer MaterialCB : register(MATERIAL_SLOT)
{
    float3 albedo;
    float metallic;
    float roughness;
    float ao;
}




[fn]
float3 GetEye()
{
    return perViewCB.Eye;
}

[fn]
float4x4 GetOrthoProjMat()
{
    return perViewCB.OrthoProjection;
}

[fn]
float4x4 GetViewMatrix()
{
    return perViewCB.View;
}

[fn]
float4x4 GetProjMat()
{
    return perViewCB.Projection;
}

[fn]
float4x4 GetViewProjMat()
{
    return perViewCB.ViewProjection;
}

[fn]
float3 GetNormal(float3 normal)
{
    float4x4 ModelView = mul(GetViewMatrix(), Model);
    return normalize(mul((float3x3) Model, normal));
}

[fn]
float4 Transform(in float3 Pos)
{
#if 0
    // NOTE: ok, its worked
    matrix mvp = mul(GetViewProjMat(), World);
    output.Pos = mul(mvp, float4(IN.Pos, 1));
#else
    // NOTE: with first matrix in mul no need transpose matrix on cpu side
    //output.Pos = mul(float4(IN.Pos, 1), MVP);
#endif
    return mul(MVP, float4(Pos, 1));
}

[fn]
float4 WorldTransofrm(in float3 Pos)
{
    return mul(Model, float4(Pos, 1));
}

[fn]
float4 ModelViewTransofrm(in float3 Pos)
{
    return mul(MV, float4(Pos, 1));
}

[fn]
// same function declaration style as vertex shaders
// pixel shaders return the colour value of the pixel (hence the float4)
float4 GrayScale(float4 color) : SV_Target0
{
  // greyscale the pixel colour values
  // - perform a dot product between the pixel colour and the specified vector
  // - 0.222, 0.707, 0.071 is found throughout image processing for gray scale effects.
    float3 grey = dot(float3(0.222, 0.707, 0.071), color.rgb);
  
  // return the pixel colour in the form of a float4.          
    return float4(grey.rgb, color.a);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
[fn]
half4 GetTexture2DGrad(Texture2D tex, SamplerState samplerState, float2 uv, float2 ddxUV, float2 ddyUV) { return tex.SampleGrad(samplerState, uv.xy, ddxUV, ddyUV ); }
[fn]
half4 GetTexture2DLod(Texture2D tex, SamplerState samplerState, float4 uv)                              { return tex.SampleLevel(samplerState, uv.xy, uv.w); }
[fn]
half2 GetTexture2DLod(Texture2D<float2> tex, SamplerState samplerState, float4 uv)                      { return tex.SampleLevel(samplerState, uv.xy, uv.w); }
[fn]
half4 GetTexture2DLod(Texture2D tex, SamplerState samplerState, float2 uv, float Lod)                   { return tex.SampleLevel(samplerState, uv.xy, Lod); }
[fn]
half4 GetTexture2DProj(Texture2D tex, SamplerState samplerState, float4 uv)                             { return tex.Sample(samplerState, uv.xy * rcp(uv.w)); }
[fn]
half2 GetTexture2DProj(Texture2D<float2> tex, SamplerState samplerState, float4 uv)                     { return tex.Sample(samplerState, uv.xy * rcp(uv.w)); }
[fn]
half4 GetTexture2DBias(Texture2D tex, SamplerState samplerState, float4 uv)                             { return tex.SampleBias(samplerState, uv.xy, uv.w); }
[fn]
half4 GetTexture2D(Texture2D tex, SamplerState samplerState, float2 uv)                                 { return tex.Sample(samplerState, uv); }
[fn]
half4 GetTextureCube(TextureCube tex, SamplerState samplerState, float3 uv)                             { return tex.Sample(samplerState, uv); }
[fn]
half4 GetTextureCubeLod(TextureCube tex, SamplerState samplerState, float4 uv)                          { return tex.SampleLevel(samplerState, uv.xyz, uv.w); }

////////////////////////////////////////////////////////////////////////////////////////////////////
[fn]
half2 GetXYNormalMap(Texture2D bumpTex, float2 bumpTC)                                           { return GetTexture2D(bumpTex, ssMaterialAnisoHigh, bumpTC).yx; }
[fn]
half2 GetXYNormalMap(Texture2D bumpTex, SamplerState samplerState, float2 bumpTC)                { return GetTexture2D(bumpTex, samplerState, bumpTC).yx; }
[fn]
half2 GetXYNormalMapLod(Texture2D bumpTex, SamplerState samplerState, float4 bumpTC)             { return GetTexture2DLod(bumpTex, samplerState, bumpTC).yx; }
[fn]
half2 GetXYNormalMapGrad(Texture2D bumpTex, float2 bumpTC, float2 ddx_bumpTC, float2 ddy_bumpTC) { return GetTexture2DGrad(bumpTex, ssMaterialAnisoHigh, bumpTC, ddx_bumpTC, ddy_bumpTC).yx; }


////////////////////////////////////////////////////////////////////////////////////////////////////

[fn]
half  GetAlphaTex(Texture2D tex, float2 texTC)                                                      { return GetTexture2D(tex, ssMaterialAnisoHigh, texTC.xy).a; }// alpha test value in alpha channel
[fn]
half4 GetDiffuseTex(Texture2D tex, float2 texTC)                                                    { return GetTexture2D(tex, ssMaterialAnisoHigh, texTC.xy); }
[fn]
half4 GetDiffuseTexGrad(Texture2D tex, float2 texTC, float2 ddxUV, float2 ddyUV)                    { return GetTexture2DGrad(tex, ssMaterialAnisoHigh, texTC.xy, ddxUV, ddyUV ); }
[fn]
half4 GetDiffuseTexLod(Texture2D tex, float4 texTC)                                                 { return GetTexture2DLod(tex, ssMaterialAnisoHigh, texTC.xyzw); }
[fn]
half4 GetDiffuseTexProj(Texture2D tex, float4 texTC)                                                { return GetTexture2DProj(tex, ssMaterialAnisoHigh, texTC.xyzw); }
[fn]
half2 GetDiffuseTexProj(Texture2D<float2> tex, float4 texTC)                                        { return GetTexture2DProj(tex, ssMaterialAnisoHigh, texTC.xyzw); }
[fn]
half4 GetDiffuseTexBias(Texture2D tex, float4 texTC)                                                { return GetTexture2DBias(tex, ssMaterialAnisoHigh, texTC.xyzw); }
[fn]
half4 GetCustomTex(Texture2D tex, float2 texTC)                                                     { return GetTexture2D(tex, ssMaterialAnisoHigh, texTC.xy); }
[fn]
half4 GetCustomTexLod(Texture2D tex, float4 texTC)                                                  { return GetTexture2DLod(tex, ssMaterialAnisoHigh, texTC.xyzw); }
[fn]
half4 GetDiffuse2Tex(Texture2D tex, float2 texTC)                                                   { return GetCustomTex(tex, texTC.xy); }
[fn]
half4 GetDiffuse2TexLod(Texture2D tex, float4 texTC)                                                { return GetCustomTexLod(tex, texTC.xyzw); }
[fn]
half4 GetDiffuseDecalTex(Texture2D tex, float2 texTC)                                               { return GetTexture2D(tex, ssMaterialAnisoHighBorder, texTC.xy); }
[fn]
half  GetHeightTex(Texture2D tex, float2 texTC)                                                     { return GetTexture2D(tex, ssMaterialTrilinear, texTC.xy); }
[fn]
half  GetHeightTexLod(Texture2D tex, float4 texTC)                                                  { return GetTexture2DLod(tex, ssMaterialTrilinear, texTC.xyzw); }
[fn]
half4 GetHeight2Tex(Texture2D tex, float2 texTC)                                                    { return GetTexture2D(tex, ssMaterialTrilinear, texTC.xy); }
[fn]
half4 GetHeight2TexLod(Texture2D tex, float4 texTC)                                                 { return GetTexture2DLod(tex, ssMaterialTrilinear, texTC.xyzw); }
